% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/remove.outlier.R
\name{remove.outlier}
\alias{remove.outlier}
\title{Removing outliers from count data}
\usage{
remove.outlier(counts, X = NULL, U = NULL, contrast = list(mean = NULL,
  dispersion = NULL), offsets = NULL, check = "contrast", ZI = TRUE,
  verbose = TRUE, cut.off = outlier.cutoff(0.05), min.sample.size = 50,
  mc.cores = 1, conserv = TRUE, ...)
}
\arguments{
\item{counts}{matrix or data frame containing gene expression counts data}

\item{X}{vector or matrix containing covariates in the mean GLM.}

\item{U}{vector or matrix containing covariates in the dispersion GLM,
which can be different from X.}

\item{contrast}{list containing contrast matices for mean and dispersion.}

\item{offsets}{numeric vector of same size as rows of counts giving offsets for use in log-linear models.}

\item{check}{which covariate(covariates) to check. if check="contrast", outliers 
influential on the effects of contrasts will be checked; if check="other", outliers 
influential on the effects of all other covariates (except contrasts) will be checked; 
if check="all", outliers influential on the effects of all covariates will be checked. 
In addition, outliers influential towards specific covariate(/covariates) can be checked.}

\item{ZI}{logical, if True (defualt), the effect of zero-inflation will be considered.}

\item{verbose}{logical, if True, progress will be reported.}

\item{cut.off}{cutoff point defining the significance level of outlier selections.}

\item{min.sample.size}{threshold to keep mininum valid sample size. Default is 50.}

\item{mc.cores}{integer equals to or greater than 1 (default), indicating how many cores 
will be used in computation. If mc.cores > 0, then parallel processes 
will be used, based on 'parallel' package.}

\item{conserv}{logical, if TRUE (default), outlier detection will skip any gene with estimation 
error for either coefficients or standard errors of coefficients and label it as an error; 
if FALSE, outlier detection will only skip any gene with estimation error 
on coefficients.}

\item{...}{other arguments could be passed to outlier checking.}
}
\value{
a list containing updated count data and summary information.
\item{count}{count matrix, in which outliers are set to NA's}
\item{outliers}{a matrix containing two columns. 1. status, indicating outlier checking status. 
                 if 'status' is not equal to 0, it indicates an error occurred in the checking process.
                 2. num.outliers, numbers of outliers found at each gene.}
}
\details{
  MDSeq requires sufficient samples and variability within samples to provide variance estimation.  
  Status=1 error will be produced if sample size minus numbers of outliers is less than min.sample.size (with default at 50), 
  and Status=2 error will be produced when variance cannot be estimated, such as when all cases or all controls have zero counts.  
  The MDSeq does not pool variances across genes in order to allow the interpretation of gene expression variability.
}
\description{
Outlier influential upon the effects of specific covariate/covariates will be removed 
from a matix of count data.
}
\examples{
library(MDSeq)
data(sampleData)

#expression
dat <- sample.exprs
dim(dat)

# covariates
X <- sample.pheno[,c("X1","X2")]
# group information
group <- sample.pheno$group

# lowly expressed gene filtered by mean cpm value across all samples
dat.filtered <- filter.counts(dat, mean.cpm.cutoff = 0.1) 
dim(dat.filtered)

# design matrix and constrast setting
group <- factor(sample.pheno$group, labels = c("Control", "Case"))
# make design matrix with proper contrast setting
groups <- get.model.matrix(group)

# normalization factor was calculated by using TMM method
# and used as an offset in mean-disperison GLM
# require(edgeR)
cnf <- calcNormFactors(dat.filtered, method="TMM") 
libsize <- colSums(dat.filtered)              #normalization factor
rellibsize <- libsize/exp(mean(log(libsize))) #relative library size
nf <- cnf * rellibsize                        #final normalization factor including library size

# check outliers using parallel process with 4 threads
# the first 100 genes were used as an example
dat.checked <- remove.outlier(dat.filtered[1:100,], X=X, U=X, contrast = groups, 
                              offsets = nf, mc.cores = 4)

# status of outlier checking
table(dat.checked$outlier$status)

# frequency distribtuion of outliers
table(dat.checked$outlier$num.outliers)

# remove genes with status flag other than 0
counts <- dat.checked$count[dat.checked$outliers$status==0,]
dim(counts)

}
\seealso{
outlier checking of single gene is done by check.outlier.
}

